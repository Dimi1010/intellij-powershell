{
  parserClass="com.intellij.plugin.powershell.lang.parser.PowerShellParser"
  parserImports=["static com.intellij.lang.parser.GeneratedParserUtilBase.*;"]

  psiImplUtilClass="com.intellij.plugin.powershell.psi.impl.PowerShellPsiImplUtil"

  parserUtilClass="com.intellij.plugin.powershell.lang.parser.PowerShellGeneratedParserUtil"

    extends="com.intellij.plugin.powershell.psi.impl.PowerShellPsiElementImpl"
    implements="com.intellij.plugin.powershell.psi.PowerShellPsiElement"

    psiClassPrefix="PowerShell"
    psiImplClassSuffix="ImplGen"
    psiPackage="com.intellij.plugin.powershell.psi"
    psiImplPackage="com.intellij.plugin.powershell.psi.impl"

    elementTypeHolderClass="com.intellij.plugin.powershell.psi.PowerShellTypes"
    elementTypeClass="com.intellij.plugin.powershell.lang.parser.PowerShellElementType"
    tokenTypeClass="com.intellij.plugin.powershell.lang.lexer.PowerShellTokenType"
    tokens = [

    // comparison operators
    OP_C = 'regexp:(-as|-ccontains|-ceq|-cge|-cgt|-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|-creplace|-csplit|-eq|-ge|-gt|-icontains|-ieq|-ige|-igt|-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-notcontains|-notin|-notlike|-notmatch|-replace|-shl|-shr|-split)'

    OP_MR='regexp:(*>&1|2>&1|3>&1|4>&1|5>&1|6>&1|*>&2|1>&2|3>&2|4>&2|5>&2|6>&2)'
    OP_FR='regexp:(>|>>|2>|2>>3>|3>>4>|4>>|5>|5>>6>|6>>*>|*>>|<)'
    OP_NOT='-not'
    OP_BNOT='-bnot'
    EXCL_MARK='!'

  // NewLines and spaces //
    NLS ='regexp:[\ \t\f]*(\r|\n|\r\n)((\r|\n|\r\n)|([\ \t\f])*)*'
    LF = 'regexp:(\r|\n|\r\n)+'


    LP='('
    RP=')'
    SQBR_L='['
    SQBR_R=']'
    PATH_SEP='\'

    EXPANDABLE_STRING='regexp:"([^"\\]|\\.)*"'
    VERBATIM_STRING="regexp:'[^']*'"
    EXPANDABLE_HERE_STRING='regexp:@"(\s)*(\r|\n|\r\n)(([^"\\]|\\.)+(\r|\n|\r\n))?(\s)*"@'
    VERBATIM_HERE_STRING="regexp:@\'(\s)*(\r|\n|\r\n)(([^'\\]|\\.)+(\r|\n|\r\n))?(\s)*\'@"
    DEC_INTEGER='regexp:[0-9abcdef][0-9]*(l|L|d|D)?(kb|mb|gb|tb|pb)?'
    HEX_INTEGER='regexp:[0-9abcdef][0-9]*(l|L)?(kb|mb|gb|tb|pb)?'
    REAL_NUM='regexp:[0-9]+\.[0-9]*([Ee][+-]?[0-9])(l|L|d|D)?(kb|mb|gb|tb|pb)?|\.[0-9]+([Ee][+-]?[0-9])?(l|L|d|D)?(kb|mb|gb|tb|pb)?|[0-9]+[Ee][+-]?[0-9]+(l|L|d|D)?(kb|mb|gb|tb|pb)?'

    DEC_EXPONENT='regexp:[Ee][+-]?[0-9]+'

    //keywords
    begin='begin'
    break='break'
    catch='catch'
    class='class'
    continue='continue'
    data='data'
    define='define'
    do='do'
    dynamicparam='dynamicparam'
    else='else'
    elseif='elseif'
    end='end'
    exit='exit'
    filter='filter'
    finally='finally'
    for='for'
    foreach='foreach'
    from='from'
    function='function'
    if='if'
    in='in'
    inlinescript='inlinescript'
    parallel='parallel'
    param='param'
    process='process'
    return='return'
    switch='switch'
    throw='throw'
    trap='trap'
    try='try'
    until='until'
    using='using'
    var='var'
    while='while'
    workflow='workflow'
    //since v4
    configuration='configuration'

    //variable
    SIMPLE_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+'
    ///Any Unicode character except
//       		{		}		(		)		;		,		|		&		$
//       		`   (The backtick character U+0060)
//       		double-quote-character
//       		single-quote-character
//       		whitespace
//       		new-line-character
//       escaped-character

//    GENERIC_ID='regexp:([^\}\{\(\)\,\;\"\`\|\&\$\s]|(`.))+' //todo ' and \s ???
//    GENERIC_ID='regexp:({SIMPLE_ID}|-)+' //todo ' and \s ???
//    BRACED_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+' //todo: create proper regex
    BRACED_ID='regexp:([^\}\`\s]|(`.))+'
    BACKTICK='`'
    VAR_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+'
//    ESCAPED_CHAR='regexp:`.'//2.3.7 Escaped characters p.30
//    NWS='regexp:[^ ]'
//    SIMPLE_NAME='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\_)(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_)+'//todo: in lexer tokens order and composition
//    TYPE_NAME='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_)+'


    SINGLE_LINE_COMMENT='regexp:\#([^\n\r])*'
    DELIMITED_COMMENT='regexp:\<\#([#]*[^#>]+)*\#+\>'
    RAW_LBR='«'
    RAW_RBR='»'
    MULTI_LINE_COMMENT_START='(*'
    MULTI_LINE_COMMENT_END='*)'

    COMMA=','
    LCURLY='{'
    RCURLY='}'
    COLON=':'
    COLON2='::'
    DS='$'
    AT='@'
    PERS='%'
    DIV='/'
    STAR='*'
    HASH='#'
    DEL_COMENT_START='regexp:\<\#'
    DEL_COMENT_END='regexp:\#+\>'
    VERBATIM_ARG_START='--%'
    VERBATIM_ARG_INPUT='regexp:[^\|\r\n]'
    BRACED_VAR_START='${'

    EQ='='
    PIPE='|'
//    AMP_ARG='regexp:\&[^&\s]'
    AMP='&'
    PP='++'
    MM='--'
    DOT='.'
    DOT_DOT='..'
    SEMI=';'
    PLUS='+'
    DASH='regexp:[\-\–\—\―]'
//    PARAM_ARGUMENT='regexp:([\w][\w$0-9\-]*)' //todo
    LETTERS='regexp:[a-zA-Z]+'
//    ALNUM='regexp:\p{Alnum}+'
    PARAM_TOKEN='regexp:\-(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\_|\?)[^\{\}\(\)\;\,\|\&\.\[\:\s\n\r]+:?'

    space = 'regexp:\s+' //???
  ]
    extends(".*expression")="expression"
    consumeTokenMethod(".*(expression|recover|condition)")="consumeTokenFast"
}


private top_level_element ::= sep* ( top_script_block | statement_list | configuration_block_list )?
{recoverWhile=top_level_recover}
private top_level_recover ::= !(reserved_statement_keywords | sep | nls | RCURLY | LCURLY | RP)
private configuration_block_list ::= configuration_block (statement_terminators configuration_block)* statement_terminators?
configuration_block ::= 'configuration' nls? configuration_name nls? LCURLY nls? configuration_block_body? nls? RCURLY
{pin=1 recoverWhile=configuration_block_recover}
private configuration_block_recover ::= !(statement_terminators? ('configuration' | <<eof>>))
private configuration_name ::= function_name

configuration_block_body ::= top_script_block
{elementType=block_body recoverWhile=configuration_block_body_recover}
private configuration_block_body_recover ::= !(RCURLY (nls? ('configuration' | <<eof>>)))

//node_block ::= node_token nls? node_name nls? LCURLY nls? node_block_body? nls? RCURLY {pin=1} //possible variant: node_token command_call_expression
node_block ::= node_token nls? generic_argument_rule+
{pin=1}

private node_token ::= SIMPLE_ID
//node_name ::= primary_expression | statement_rule | identifier  //function_name

resource_block ::= resource_type nls? ( resource_name nls? resource_block_tail | resource_block_tail )//todo: or predicate is faster?
private resource_block_tail ::= LCURLY nls? resource_block_body? nls? RCURLY
resource_block_body ::= hash_literal_body
{elementType=block_body}

private resource_type ::= SIMPLE_ID
private resource_name ::= /*!(nls? LCURLY)*/ function_name //function_name can be parsed as script_block_expression
private parse_resource_block ::= is_dsc resource_block
private parse_node_block ::= is_dsc node_block

private statement_block ::= LCURLY nls? block_body? nls? RCURLY
block_body ::= (statement_list | statement_terminators)+ {recoverWhile=statement_block_recover}

private statement_block_recover ::= !block_body_stop_tokens
private block_body_stop_tokens ::= reserved_statement_keywords | sep | nls | RCURLY

private statement_list ::= statement ( statement_terminators statement )* {pin=1 recoverWhile=top_level_recover}
private top_script_block ::= param_block? statement_terminators? script_block_body
script_block ::= top_script_block
{elementType=block_body}

private param_block ::= attribute_list? nls? 'param' nls? LP nls? script_parameter_list? nls? RP {pin=3}

private attribute_list ::= (attribute nls?)+
attribute ::= SQBR_L nls? attribute_name LP nls? attribute_arguments? nls? RP nls? SQBR_R | type_literal_expression
private attribute_name ::= type_spec

private attribute_arguments ::= attribute_argument (nls? COMMA nls? attribute_argument)*
private attribute_argument ::= simple_name '=' nls? unary_expression | simple_name | unary_expression


private script_parameter_list ::= script_parameter (nls? COMMA nls? script_parameter)*

private script_parameter ::= attribute_list? nls? target_variable_expression nls? script_parameter_default?
private script_parameter_default ::= '=' nls? expression

private script_block_body ::= named_block_list | (statement_list | statement_terminators)+

private named_block_list ::= named_block (statement_terminators named_block )*
private named_block ::= block_name nls? statement_block
private block_name ::= 'dynamicparam' | 'begin' | 'process' | 'end'

private statement ::=   if_statement
                      | (label nls?)? labeled_statement
                      | function_statement
                      | workflow_statement
                      | flow_control_statement //sep
                      | trap_pipeline
                      | try_statement
                      | data_statement
                      | inlinescript_statement
                      | parallel_statement
                      | sequence_statement
                      | parse_resource_block
                      | parse_node_block
                      | pipeline
{recoverWhile=statement_recover}
private statement_recover ::= !statement_stop_tokens
private statement_stop_tokens ::= reserved_statement_keywords | sep | nls | RCURLY | LCURLY | RP
private pipeline ::= expression redirection* pipeline_tail? &statement_end | command_call_expression verbatim_command_argument? pipeline_tail?

//B.1.11 Operators and punctuators
private assignment_operator ::= '=' | '-=' | '+=' | '*=' | '/='| '%='
private merging_redirection_operator ::= OP_MR
private file_redirection_operator ::= OP_FR
private comparison_operator ::=  OP_C
private format_operator ::= '-f'
//private dash ::= '–'

//B.1.10 Type Names
private type_name ::= type_identifier (DOT type_identifier)*

private type_identifier ::= /*TYPE_NAME |*/ SIMPLE_ID //todo in lexer (or merge?)
private array_type_name ::= type_name SQBR_L
private generic_type_name ::= type_name SQBR_L

//B.1.9 Simple Names
simple_name ::= SIMPLE_ID
{elementType=identifier}
//B.1.8 Literals
private literal ::= real_literal_expression | integer_literal_expression | string_literal_expression

//Integer Literals
integer_literal_expression ::= decimal_integer_literal | hexadecimal_integer_literal
private decimal_integer_literal ::=  DEC_INTEGER
private hexadecimal_integer_literal ::= HEX_INTEGER

//Real Literals
real_literal_expression ::= REAL_NUM

//String literals
string_literal_expression ::= expandable_string_literal | verbatim_string_literal | expandable_here_string_literal | verbatim_here_string_literal
private expandable_string_literal ::= EXPANDABLE_STRING
private verbatim_string_literal ::= VERBATIM_STRING
private verbatim_here_string_literal ::= VERBATIM_HERE_STRING //todo create proper char goups
private expandable_here_string_literal ::= EXPANDABLE_HERE_STRING //todo create proper char goups


//B.1.7 Commands


//B.1.6 Variables
private variable ::= '$$' | '$?' | '$^' |  simple_variable | braced_variable

//reference_variable ::= variable

target_variable_expression ::= variable
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellTargetVariableImpl"
implements="com.intellij.plugin.powershell.psi.PowerShellVariable"}

private simple_variable ::= (DS | AT) variable_scope? variable_name_simple

private variable_scope ::= 'global:' | 'local:' | 'private:' | 'script:' | 'using:' | 'workflow:' | variable_namespace
private variable_namespace ::= SIMPLE_ID ':'
variable_name_simple ::= SIMPLE_ID | VAR_ID
{elementType=identifier}
private braced_variable ::= BRACED_VAR_START variable_scope? variable_name_braced RCURLY
variable_name_braced ::= SIMPLE_ID  | BRACED_ID
{elementType=identifier}

//expressions
expression ::=   assignment_expression
               | logical_expression
               | bitwise_expression
               | comparison_expression
               | additive_expression
               | multiplicative_expression
               | format_expression
               | range_expression
               | array_literal_expression
               | unary_expression

assignment_expression ::= expression assignment_operator statement
{rightAssociative=true methods=[getTargetVariables] pin=2}

logical_expression ::=   expression ( '-and' | '-or' | '-xor' ) nls? expression

bitwise_expression ::=  expression ('-band' | '-bor' | '-bxor' )  nls? expression

comparison_expression ::= expression comparison_operator nls? expression

additive_expression ::= expression (( PLUS | DASH ) nls? expression)+

multiplicative_expression ::= expression ( STAR | DIV | PERS) nls? expression

format_expression ::= expression format_operator nls? expression

range_expression ::= expression DOT_DOT nls? expression

array_literal_expression ::= expression (',' nls? expression)+


private op_join_text ::= '-join' | '–join' | '—join' | '―join'
private op_split_text ::= '-split' | '–split' | '—split' | '―split'
private prefix_op ::= OP_BNOT | EXCL_MARK | OP_NOT | MM | PP | op_split_text | op_join_text | COMMA | PLUS | DASH
unary_expression ::= expression_with_unary_operator | primary_expression
private expression_with_unary_operator ::= prefix_op nls? unary_expression | cast_expression
//                                            ','     nls? lvalue //unary_expression
//                                           | '-not'  nls? lvalue //unary_expression
//                                           | '!'     nls? lvalue //unary_expression
//                                           | '-bnot' nls? lvalue //unary_expression
//                                           | PLUS     nls? lvalue// unary_expression
//                                           | MINUS    nls? lvalue //unary_expression
//                                           | PP nls? lvalue //pre_increment_expression
//                                           | MM nls? lvalue //pre_decrement_expression
//                                           | cast_expression
//                                           | '-split' nls? lvalue //unary_expression
//                                           | '-join'  nls? lvalue //unary_expression
//private lvalue ::= simple_lvalue property_or_array_reference_op*
//private property_or_array_reference_op ::= SQBR_L expression SQBR_R | DOT (simple_name | value)
//private pre_increment_expression ::= '++' nls? lvalue //unary_expression
//private pre_decrement_expression ::= '--' nls? lvalue //unary_expression

cast_expression ::= type_literal_expression unary_expression

//private attributed_expression ::= type_literal variable

private pipeline_tail ::= ( PIPE nls? command_call_expression )+

command_call_expression ::= command_invocation_operator ( (command_module command_name_expr command_element* ) | command_name_expr command_element* ) | command_name_expression command_element*
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellCallableReferenceExpression"
implements="com.intellij.plugin.powershell.psi.PowerShellReference"}

private command_name_expression ::= path_expression | command_name//todo parse path_item where appropriate: path_item all bare identifiers including command_name
command_name ::= generic_token_with_sub_expr | generic_token_part | allowed_identifier_keywords //generic_token


//command_name ::= generic_ref_token_with_sub_expr | generic_token_part//generic_token
private generic_token_with_sub_expr ::= generic_token_with_subexpr_start statement_list? RP nws command_name
//private generic_ref_token_with_sub_expr ::= generic_ref_token_with_subexpr_start statement_list? RP nws command_name
private generic_token_with_subexpr_start ::= generic_token_part DS nws LP
//private generic_ref_token_with_subexpr_start ::= generic_token_part DS nws LP
private generic_token_part ::= expandable_string_literal | verbatim_here_string_literal | target_variable_expression | generic_token_chars

private generic_token_chars ::= generic_id_part_tokens_start ( nws generic_id_part_tokens )*
private generic_id_part_tokens_start ::= SIMPLE_ID | GENERIC_ID_PART | STAR | PERS
private generic_id_part_tokens ::= generic_id_part_tokens_start | DOT | PATH_SEP | DIV

private command_element ::= command_parameter | command_argument | redirection
private command_invocation_operator ::= '&' | DOT
private command_module ::= primary_expression

private redirection ::= merging_redirection_operator | file_redirection_operator  redirected_file_name
private redirected_file_name ::= command_argument | primary_expression


sequence_statement ::= 'sequence' statement_block

parallel_statement ::= 'parallel' statement_block

inlinescript_statement ::= 'inlinescript' statement_block


data_statement ::= 'data' nls? data_name? nls? data_commands_allowed? nls? statement_block {pin=1}
private data_name ::= simple_name
private data_commands_allowed ::= '-supportedcommand' nls? data_commands_list
private data_commands_list ::= data_command ( nls? ',' nls? data_command )*
private data_command ::= command_name_expr
private command_name_expr ::= primary_expression | command_name_expression

private allowed_identifier_keywords ::= 'param'|'until'|'workflow'|'end'|'define'|'finally'|'parallel'|'continue'|'begin'|'dynamicparam'|'in'
|'process'|'break'|'else'|'inlinescript'|'catch'
private reserved_statement_keywords ::= 'class'|'data'|'do'|'elseif'|'exit'|'filter'|'for'|'foreach'|'from'|'function'|'if'|'return'|'switch'|'throw'
|'trap'|'try'|'using'|'var'|'while'|'configuration'



try_statement ::= 'try' nls? statement_block nls? (catch_clause nls?)* finally_clause? {pin=1}
private catch_clause ::= 'catch' nls? catch_type_list? nls? statement_block
private catch_type_list ::= type_literal_expression nls? ( ',' nls? type_literal_expression nls? )*
private finally_clause ::= 'finally' nls? statement_block

private trap_pipeline ::= trap_statement statement?
trap_statement ::= 'trap' nls? type_literal_expression? nls? statement_block {pin=1}
type_literal_expression ::= SQBR_L type_spec SQBR_R
private type_spec ::=   array_type_name nls? dimension? SQBR_R | generic_type_name nls? generic_type_arguments SQBR_R | type_name
private dimension ::= COMMA+ //',' | dimension ','
private generic_type_arguments ::= type_spec nls? (',' nls? type_spec)*


//attributes

flow_control_statement ::= break_continue_statement | throw_return_exit_statement
private break_continue_statement ::= ('break' | 'continue') label_expression?
private throw_return_exit_statement ::= ('throw' | 'return' | 'exit') pipeline? {pin=1}
private label_expression ::= simple_name | unary_expression


function_statement ::= ('function' | 'filter') nls? function_statement_tail {pin=1}
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellAbstractComponent"
implements="com.intellij.plugin.powershell.psi.PowerShellComponent"}
workflow_statement ::= 'workflow' nls? function_statement_tail
{elementType=function_statement}
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellAbstractComponent"
implements="com.intellij.plugin.powershell.psi.PowerShellComponent"}

private function_statement_tail ::= function_name nls? function_parameter_declaration? nls? LCURLY nls? script_block? nls? RCURLY
private function_name ::= primary_expression | identifier //command_name_expr
identifier ::= generic_identifier
private generic_identifier ::=  generic_token_with_sub_expr | generic_token_part


private function_parameter_declaration ::= LP parameter_list nls? RP
//private parameter_list ::= parameter_with_initializer (COMMA parameter_with_initializer)*
private parameter_list ::= script_parameter_list
//private script_parameter_list ::= script_parameter (nls? ',' script_parameter)*
//private parameter_with_initializer ::= simple_lvalue [ EQ expression ]
//private simple_lvalue ::= target_variable
//target_variable ::=  variable //DS ALNUM|DS LCURLY BRACED_ID RCURLY//Q_ANYCHAR


private labeled_statement ::=   switch_statement
                              | foreach_statement
                              | for_statement
                              | while_statement
                              | do_statement
switch_statement ::= 'switch' nls? switch_parameter* switch_condition switch_body {pin=1}
private switch_parameter ::=   '-regex'
                             | '-wildcard'
                             | '-exact'
                             | '-casesensitive'
                             | '-parallel'

private switch_condition ::= LP nls? pipeline nls? RP | '-file' nls? switch_filename
private switch_filename ::= command_argument | primary_expression
//private generic_argument_rule ::= array_literal_expression !(nws PATH_SEP | nws COLON) | command_name_expression (nls? COMMA command_name_expression)*
private generic_argument_rule ::= generic_chars_or_path_expression (nls? COMMA generic_chars_or_path_expression)* | array_literal_expression
private generic_chars_or_path_expression ::= path_expression | command_name_char_tokens
command_name_char_tokens ::= generic_token_chars | allowed_identifier_keywords
{elementType=command_name}
command_argument ::= generic_argument_rule

path_expression ::=  path_item nws (
                              (
                              ((   (PATH_SEP nws COLON2 nws) (path_item nws PATH_SEP nws COLON2 nws)*  //provider+ drive?
                                  (nws path_item nws COLON nws PATH_SEP)? //drive
                               )
                              |
                               (
                                  (COLON nws PATH_SEP)     // or drive
                               )
                               )
                              (nws path_item) (nws PATH_SEP nws path_item)* (nws PATH_SEP)? // container+
                              )//provider and/or drive and container+
                              | (PATH_SEP nws path_item)+ //just container+
                              | COLON (nws PATH_SEP)?     // just drive
                              | PATH_SEP //just PATH_SEP
                                ) | PATH_SEP (nws (path_expression | path_item))?//todo do not produce another path_expression node
                                  | relative_path_item             // just relative path
path_item ::= path_item_name
relative_path_item ::= relative_path
{elementType=path_item}

private path_item_name ::= relative_path | path_name_tokens | allowed_identifier_keywords | target_variable_expression /*reference_variable*/
private path_name_tokens ::= path_name_part_tokens_start (nws (path_name_part_tokens_start | DOT))*
private path_name_part_tokens_start ::= generic_id_part_tokens_start | DEC_INTEGER
private relative_path ::= DOT | DOT_DOT | PATH_SEP
command_parameter ::= PARAM_TOKEN | OP_C | OP_NOT | OP_BNOT
verbatim_command_argument ::= VERBATIM_ARG_START VERBATIM_ARG_INPUT //(verbatim_command_string | AMP_ARG | generic_token_chars )+
//private verbatim_command_string ::= EXPANDABLE_STRING //TODO: 02/09/17 variable substitution:


private primary_expression ::= value (invocation_expression | member_access | element_access | post_increment_expression | post_decrement_expression)*

private left member_access ::= nws ( DOT | COLON2 ) nws member_name
private left element_access ::= SQBR_L nls? expression nls? SQBR_R
left invocation_expression ::= (DOT | COLON2 ) member_name LP nls? argument_expression_list? nls? RP
private argument_expression_list ::= expression ( nls? ',' nls? expression)*
left post_increment_expression ::= PP
left post_decrement_expression ::= MM

private member_name ::=   simple_name
                        | string_literal_expression
//->                        | string_literal_with_subexpression
                        | expression_with_unary_operator //prefix_op unary_expression //

                        | value

private value ::=   parenthesized_expression
                  | sub_expression
                  | array_expression
                  | script_block_expression
                  | hash_literal_expression
                  | literal
                  | type_literal_expression
//                  | prefix_op lvalue
                  | cast_expression
                  | target_variable_expression

parenthesized_expression ::= LP nls? pipeline nls? RP

sub_expression ::= DS LP nls? statement_list? nls? RP

array_expression ::= AT LP nls? statement_list? nls? RP

script_block_expression ::= LCURLY nls? script_block? nls? RCURLY

hash_literal_expression ::= AT LCURLY nls? hash_literal_body? nls? RCURLY //'@{' nls? hash_literal_body? nls? '}'
private hash_literal_body ::= hash_entry ( statement_terminators hash_entry )*
private hash_entry ::= key_expression '=' nls? statement

key_expression ::= simple_name | unary_expression

// todo Note no whitespace is allowed after primary_expression.
//->private member_access ::= primary_expression ( DOT | '::' ) member_name

//todo  Note no whitespace is allowed between primary_expression and [.
//->private element_access ::= primary_expression '[' nls? expression nls? ']'

//->//todo  Note no whitespace is allowed after primary_expression.
//->private invocation_expression ::= primary_expression (DOT | '::') member_name argument_list
//->
//->private argument_list ::= LP argument_expression_list? nls? RP
//->private argument_expression_list ::= argument_expression ( ',' argument_expression)*
//->
//->private argument_expression ::=  nls? logical_argument_expression
//->
//->private logical_argument_expression ::= bitwise_argument_expression ( ('-and' | '-or' | '-xor') nls? bitwise_argument_expression )*
//->
//->private bitwise_argument_expression ::= comparison_argument_expression ( ('-band' | '-bor' | '-bxor') nls? comparison_argument_expression )*
//->
//->private comparison_argument_expression ::= additive_argument_expression ( comparison_operator nls? additive_argument_expression )*
//->
//->private additive_argument_expression ::= multiplicative_argument_expression ( (PLUS | MINUS) nls? multiplicative_argument_expression )*
//->
//->private multiplicative_argument_expression ::= format_argument_expression ( ('*' | '/' | '%') nls? format_argument_expression )*
//->
//->private format_argument_expression ::= range_argument_expression ( format_operator nls? range_argument_expression )*
//->
//->private range_argument_expression ::= unary_expression ( '..' nls? unary_expression )*
//->

private switch_body ::= nls? '{' nls? switch_clause+ '}'
private switch_clause ::= switch_clause_condition statement_block statement_terminators?
private switch_clause_condition ::= command_argument | primary_expression


foreach_statement ::= 'foreach' nls? '-parallel'? nls?
                                LP nls?   target_variable_expression   nls? 'in' nls? pipeline nls? RP nls? statement_block
{pin=1}
//todo simplify
for_statement ::=   'for' nls? LP
                                  nls? for_initializer? sep
                                  nls? for_condition? sep
                                  nls? for_iterator?
                                  nls? RP nls? statement_block
{pin=1}
private for_initializer ::= pipeline
private for_condition ::= pipeline
private for_iterator ::= pipeline


while_statement ::= 'while' nls? LP nls? while_condition nls? RP nls? statement_block {pin=1 recoverWhile=statement_recover}
private while_condition ::= pipeline


do_statement ::= 'do' nls? statement_block nls? ( 'while' | 'until' ) nls? LP nls? while_condition nls? RP {pin=1 /*recoverWhile=statement_recover*/}


if_statement ::= 'if' nls? LP nls? pipeline nls? RP nls? statement_block (nls? elseif_clause)* (nls? else_clause)? {pin=1 /*recoverWhile=statement_recover*/}
private elseif_clause ::= 'elseif' nls? LP nls? pipeline nls? RP nls? statement_block
private else_clause ::= 'else' nls? statement_block

sep ::= SEMI |  NLS | new_line_char | comment //COMMENT //hide psi
private statement_end ::= sep | RCURLY | RP | <<eof>>//ex: parethnisized_expression $AllNodes.Where{$_.Role -eq "WebServer"}
private nls ::= (comment? NLS comment?)+ //NLS
private new_line_char ::= LF

comment ::= !is_id requires_comment | !is_id SINGLE_LINE_COMMENT | DELIMITED_COMMENT
private requires_comment ::= HASH nws 'requires' ws command_argument+

private statement_terminators ::= sep+

private label ::= ':' nws SIMPLE_ID// todo ALNUM?

private nws ::= <<isNotWhiteSpace>>

private ws ::= <<isWhiteSpace>>
private is_id ::= <<isIdentifierBefore>>
private is_dsc ::= <<is_parsing_configuration_block>>