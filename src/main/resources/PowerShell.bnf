{
  parserClass="com.intellij.plugin.powershell.lang.parser.PowerShellParser"
  parserImports=["static com.intellij.lang.parser.GeneratedParserUtilBase.*;"]

  psiImplUtilClass="com.intellij.plugin.powershell.psi.impl.PowerShellPsiImplUtil"

  parserUtilClass="com.intellij.plugin.powershell.lang.parser.PowerShellGeneratedParserUtil"

    extends="com.intellij.plugin.powershell.psi.impl.PowerShellPsiElementImpl"
    implements="com.intellij.plugin.powershell.psi.PowerShellPsiElement"

    psiClassPrefix="PowerShell"
    psiImplClassSuffix="ImplGen"
    psiPackage="com.intellij.plugin.powershell.psi"
    psiImplPackage="com.intellij.plugin.powershell.psi.impl"

    elementTypeHolderClass="com.intellij.plugin.powershell.psi.PowerShellTypes"
    elementTypeClass="com.intellij.plugin.powershell.lang.parser.PowerShellElementType"
    tokenTypeClass="com.intellij.plugin.powershell.lang.lexer.PowerShellTokenType"
    tokens = [

    // comparison operators
    OP_C = 'regexp:(-as|-ccontains|-ceq|-cge|-cgt|-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|-creplace|-csplit|-eq|-ge|-gt|-icontains|-ieq|-ige|-igt|-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-notcontains|-notin|-notlike|-notmatch|-replace|-shl|-shr|-split)'

    OP_MR='regexp:(*>&1|2>&1|3>&1|4>&1|5>&1|6>&1|*>&2|1>&2|3>&2|4>&2|5>&2|6>&2)'
    OP_FR='regexp:(>|>>|2>|2>>3>|3>>4>|4>>|5>|5>>6>|6>>*>|*>>|<)'
    OP_NOT='-not'
    OP_BNOT='-bnot'
    OP_SPLIT='-split'
    OP_JOIN='-join'
    EXCL_MARK='!'

  // NewLines and spaces //
    NLS ='regexp:[\ \t\f]*(\r|\n|\r\n)((\r|\n|\r\n)|([\ \t\f])*)*'
    LF = 'regexp:(\r|\n|\r\n)+'


    LP='('
    RP=')'
    SQBR_L='['
    SQBR_R=']'
    PATH_SEP='\'

    EXPANDABLE_STRING='regexp:"([^"\\]|\\.)*"'
    VERBATIM_STRING="regexp:'[^']*'"
    EXPANDABLE_HERE_STRING='regexp:@"(\s)*(\r|\n|\r\n)(([^"\\]|\\.)+(\r|\n|\r\n))?(\s)*"@'
    VERBATIM_HERE_STRING="regexp:@\'(\s)*(\r|\n|\r\n)(([^'\\]|\\.)+(\r|\n|\r\n))?(\s)*\'@"
    DEC_INTEGER='regexp:[0-9abcdef][0-9]*(l|L|d|D)?(kb|mb|gb|tb|pb)?'
    HEX_INTEGER='regexp:[0-9abcdef][0-9]*(l|L)?(kb|mb|gb|tb|pb)?'
    REAL_NUM='regexp:[0-9]+\.[0-9]*([Ee][+-]?[0-9])(l|L|d|D)?(kb|mb|gb|tb|pb)?|\.[0-9]+([Ee][+-]?[0-9])?(l|L|d|D)?(kb|mb|gb|tb|pb)?|[0-9]+[Ee][+-]?[0-9]+(l|L|d|D)?(kb|mb|gb|tb|pb)?'

    DEC_EXPONENT='regexp:[Ee][+-]?[0-9]+'

    //keywords
    begin='begin'
    break='break'
    catch='catch'
    class='class'
    continue='continue'
    data='data'
    define='define'
    do='do'
    dynamicparam='dynamicparam'
    else='else'
    elseif='elseif'
    end='end'
    exit='exit'
    filter='filter'
    finally='finally'
    for='for'
    foreach='foreach'
    from='from'
    function='function'
    if='if'
    in='in'
    inlinescript='inlinescript'
    parallel='parallel'
    param='param'
    process='process'
    return='return'
    switch='switch'
    throw='throw'
    trap='trap'
    try='try'
    until='until'
    using='using'
    var='var'
    while='while'
    workflow='workflow'

    //variable
    SIMPLE_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+'
    ///Any Unicode character except
//       		{		}		(		)		;		,		|		&		$
//       		`   (The backtick character U+0060)
//       		double-quote-character
//       		single-quote-character
//       		whitespace
//       		new-line-character
//       escaped-character

//    GENERIC_ID='regexp:([^\}\{\(\)\,\;\"\`\|\&\$\s]|(`.))+' //todo ' and \s ???
//    GENERIC_ID='regexp:({SIMPLE_ID}|-)+' //todo ' and \s ???
//    BRACED_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+' //todo: create proper regex
    BRACED_ID='regexp:([^\}\`\s]|(`.))+'
    BACKTICK='`'
    VAR_ID='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_|\?)+'
//    ESCAPED_CHAR='regexp:`.'//2.3.7 Escaped characters p.30
//    NWS='regexp:[^ ]'
//    SIMPLE_NAME='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\_)(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_)+'//todo: in lexer tokens order and composition
    TYPE_NAME='regexp:(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\p{Nd}|\_)+'


    SINGLE_LINE_COMMENT='regexp:\#([^\n\r])*'
    DELIMITED_COMMENT='regexp:\<\#([#]*[^#>]+)*\#+\>'
    RAW_LBR='«'
    RAW_RBR='»'
    MULTI_LINE_COMMENT_START='(*'
    MULTI_LINE_COMMENT_END='*)'

    COMMA=','
    LCURLY='{'
    RCURLY='}'
    COLON=':'
    COLON2='::'
    DS='$'
    AT='@'
    PERS='%'
    HASH='#'
    DEL_COMENT_START='regexp:\<\#'
    DEL_COMENT_END='regexp:\#+\>'
    VERBATIM_ARG_START='--%'
    VERBATIM_ARG_INPUT='regexp:[^\|\r\n]'
    BRACED_VAR_START='${'

    EQ='='
    PIPE='|'
//    AMP_ARG='regexp:\&[^&\s]'
    AMP='&'
    PP='++'
    MM='--'
    DOT='.'
    SEMI=';'
    PLUS='+'
    DASH='regexp:[\-\–\—\―]'
    PARAM_ARGUMENT='regexp:([\w][\w$0-9\-]*)' //todo
    ALNUM='regexp:p{Alnum}'
    LETTERS='regexp:[a-zA-Z]+'
    ALNUM='regexp:\p{Alnum}+'
    PARAM_TOKEN='regexp:\-(\p{Lu}|\p{Ll}|\p{Lt}|\p{Lm}|\p{Lo}|\_|\?)[^\{\}\(\)\;\,\|\&\.\[\:\s\n\r]+:?'

    space = 'regexp:\s+' //???
  ]
    extends(".*expression")="expression"
    consumeTokenMethod(".*(expression|recover|condition)")="consumeTokenFast"
}


private top_level_element ::= ( nls? top_script_block | statement_list)?

private statement_block ::= LCURLY nls? block_body? nls? RCURLY
block_body ::= sep* statement_list

private statement_list ::= statement ( statement_terminators statement? )*

private top_script_block ::= param_block? statement_terminators? script_block_body
script_block ::= top_script_block //nls? param_block? statement_terminators? script_block_body
{elementType=block_body}

private param_block ::= attribute_list? nls? 'param' nls? LP script_parameter_list? nls? RP

private attribute_list ::= (attribute nls?)+
attribute ::= SQBR_L nls? attribute_name LP attribute_arguments nls? RP nls? SQBR_R | type_literal_expression
private attribute_name ::= type_spec

private attribute_arguments ::= attribute_argument (nls? COMMA attribute_argument)*
private attribute_argument ::= nls? ( simple_name '=' nls? expression | expression | simple_name )


private script_parameter_list ::= script_parameter (nls? COMMA script_parameter)*

private script_parameter ::= attribute_list? nls? target_variable_expression nls? script_parameter_default?
private script_parameter_default ::= '=' nls? expression

private script_block_body ::= named_block_list | statement_list

private named_block_list ::= named_block (statement_terminators named_block? )*
private named_block ::= block_name statement_block statement_terminators?
private block_name ::= 'dynamicparam' | 'begin' | 'process' | 'end'

private statement ::=   if_statement
                      | label? labeled_statement
                      | function_statement
                      | flow_control_statement //sep
                      | trap_statement
                      | try_statement
                      | data_statement
                      | inlinescript_statement
                      | parallel_statement
                      | sequence_statement
                      | pipeline //sep

private pipeline ::= assignment_statement | expression redirection* pipeline_tail? | command_call_expression verbatim_command_argument? pipeline_tail?

assignment_statement ::= /*lvalue_expression*/ expression assignment_operator statement
{methods=[getTargetVariables]}

//B.1.11 Operators and punctuators
private assignment_operator ::= '=' | '-=' | '+=' | '*=' | '/='| '%='
private merging_redirection_operator ::= OP_MR
private file_redirection_operator ::= OP_FR
private comparison_operator ::=  OP_C
private format_operator ::= '-f'
//private dash ::= '–'

//B.1.10 Type Names
private type_name ::= type_identifier (DOT type_identifier)*

private type_identifier ::= TYPE_NAME | SIMPLE_ID //todo in lexer (or merge?)
private array_type_name ::= type_name SQBR_L
private generic_type_name ::= type_name SQBR_L

//B.1.9 Simple Names
simple_name ::= SIMPLE_ID
{elementType=identifier}
//B.1.8 Literals
private literal ::= real_literal_expression | integer_literal_expression | string_literal_expression

//Integer Literals
integer_literal_expression ::= decimal_integer_literal | hexadecimal_integer_literal
private decimal_integer_literal ::=  DEC_INTEGER
private hexadecimal_integer_literal ::= HEX_INTEGER

//Real Literals
real_literal_expression ::= REAL_NUM

//String literals
string_literal_expression ::= expandable_string_literal | verbatim_string_literal | expandable_here_string_literal | verbatim_here_string_literal
private expandable_string_literal ::= EXPANDABLE_STRING
private verbatim_string_literal ::= VERBATIM_STRING
private verbatim_here_string_literal ::= VERBATIM_HERE_STRING //todo create proper char goups
private expandable_here_string_literal ::= EXPANDABLE_HERE_STRING //todo create proper char goups


//B.1.7 Commands


//B.1.6 Variables
private variable ::= '$$' | '$?' | '$^' |  simple_variable | braced_variable

referenceVariable ::= variable

target_variable_expression ::= variable //'$$' | '$?' | '$^' |  simple_variable | braced_variable
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellTargetVariableImpl"
implements="com.intellij.plugin.powershell.psi.PowerShellVariable"}

private simple_variable ::= (DS | AT) variable_scope? variable_name_simple

private variable_scope ::= 'global:' | 'local:' | 'private:' | 'script:' | 'using:' | 'workflow:' | variable_namespace
private variable_namespace ::= SIMPLE_ID ':'
variable_name_simple ::= SIMPLE_ID //| VAR_ID
{elementType=identifier}
private braced_variable ::= BRACED_VAR_START variable_scope? variable_name_braced RCURLY
variable_name_braced ::= SIMPLE_ID  | BRACED_ID
{elementType=identifier}

//expressions
expression ::= logical_expression
logical_expression ::=   bitwise_expression ( ( '-and' | '-or' | '-xor' ) nls? bitwise_expression )*

bitwise_expression ::=  comparison_expression ( ('-band' | '-bor' | '-bxor' )  nls? comparison_expression )*

comparison_expression ::= additive_expression ( comparison_operator nls? additive_expression )*

additive_expression ::= multiplicative_expression ( ( PLUS | DASH ) nls? multiplicative_expression )*

multiplicative_expression ::= format_expression ( ( '*' | '/' | '%') nls? format_expression )*

format_expression ::= range_expression ( format_operator nls? range_expression )*

range_expression ::= array_literal_expression ( '..' nls? array_literal_expression )*
//range_expression ::= unary_expression ( '..' nls? unary_expression )*

array_literal_expression ::= unary_expression ( ',' nls? unary_expression )*
//array_literal_expression ::= postfix_op ( ',' nls? postfix_op )*

//
//private postfix_op ::= lvalue_expression (MM | PP) | property_or_array_reference
//private lvalue_expression ::= lvalue (PIPE lvalue)*
//property_or_array_reference ::= value property_or_array_reference_op*
//
private prefix_op ::= OP_NOT | EXCL_MARK | OP_BNOT | MM | PP | OP_SPLIT | OP_JOIN | COMMA | PLUS | DASH
private unary_expression ::= expression_with_unary_operator | primary_expression
expression_with_unary_operator ::= prefix_op nls? primary_expression | cast_expression //lvalue
//                                            ','     nls? lvalue //unary_expression
//                                           | '-not'  nls? lvalue //unary_expression
//                                           | '!'     nls? lvalue //unary_expression
//                                           | '-bnot' nls? lvalue //unary_expression
//                                           | PLUS     nls? lvalue// unary_expression
//                                           | MINUS    nls? lvalue //unary_expression
//                                           | PP nls? lvalue //pre_increment_expression
//                                           | MM nls? lvalue //pre_decrement_expression
//                                           | cast_expression
//                                           | '-split' nls? lvalue //unary_expression
//                                           | '-join'  nls? lvalue //unary_expression
//private lvalue ::= simple_lvalue property_or_array_reference_op*
//private property_or_array_reference_op ::= SQBR_L expression SQBR_R | DOT (simple_name | value)
//private pre_increment_expression ::= '++' nls? lvalue //unary_expression
//private pre_decrement_expression ::= '--' nls? lvalue //unary_expression

private cast_expression ::= type_literal_expression unary_expression //lvalue

//private attributed_expression ::= type_literal variable

private pipeline_tail ::= ( PIPE nls? command_call_expression )+

command_call_expression ::= command_name command_element* | command_invocation_operator ( (command_module command_name_expr command_element* ) | command_name_expr command_element* )
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellCallableReferenceExpression"
implements="com.intellij.plugin.powershell.psi.PowerShellReference"}

command_name ::= generic_token_with_sub_expr | generic_token_part//generic_token


//command_name ::= generic_ref_token_with_sub_expr | generic_token_part//generic_token
private generic_token_with_sub_expr ::= generic_token_with_subexpr_start statement_list? RP nws command_name
//private generic_ref_token_with_sub_expr ::= generic_ref_token_with_subexpr_start statement_list? RP nws command_name
private generic_token_with_subexpr_start ::= generic_token_part DS nws LP
//private generic_ref_token_with_subexpr_start ::= generic_token_part DS nws LP
private generic_token_part ::= expandable_string_literal | verbatim_here_string_literal | referenceVariable | generic_token_chars

private generic_token_chars ::= generic_id_part_tokens_start ( nws generic_id_part_tokens )*
private generic_id_part_tokens_start ::= SIMPLE_ID | GENERIC_ID_PART
private generic_id_part_tokens ::= generic_id_part_tokens_start | DOT | PATH_SEP

private command_element ::= command_parameter | command_argument | redirection
private command_invocation_operator ::= '&' | DOT
private command_module ::= primary_expression

private redirection ::= merging_redirection_operator | file_redirection_operator  redirected_file_name
private redirected_file_name ::= command_argument | primary_expression


sequence_statement ::= 'sequence' statement_block

parallel_statement ::= 'parallel' statement_block

inlinescript_statement ::= 'inlinescript' statement_block


data_statement ::= 'data' nls? data_name data_commands_allowed? statement_block
private data_name ::= simple_name
private data_commands_allowed ::= nls? '-supportedcommand' data_commands_list
private data_commands_list ::= nls? data_command ( ',' nls? data_command nls? )*
private data_command ::= command_name_expr
private command_name_expr ::= primary_expression | command_name




try_statement ::=   'try' statement_block (catch_clause+ | finally_clause | catch_clause finally_clause)
private catch_clause ::= nls? 'catch' catch_type_list? statement_block
private catch_type_list ::= nls? type_literal_expression nls? ( ',' nls? type_literal_expression nls? )*
private finally_clause ::= nls? 'finally' statement_block


trap_statement ::= 'trap' nls? type_literal_expression? nls? statement_block
type_literal_expression ::= SQBR_L type_spec SQBR_R
private type_spec ::=   array_type_name nls? dimension? SQBR_R | generic_type_name nls? generic_type_arguments SQBR_R | type_name
private dimension ::= COMMA+ //',' | dimension ','
private generic_type_arguments ::= type_spec nls? (',' nls? type_spec)*


//attributes

flow_control_statement ::= ('break' | 'continue') label_expression? | ('throw' | 'return' | 'exit') pipeline?
private label_expression ::= simple_name | unary_expression


function_statement ::= ('function' | 'filter' | 'workflow') nls? function_name nls? function_parameter_declaration? nls? LCURLY nls? script_block? nls? RCURLY
{mixin="com.intellij.plugin.powershell.psi.impl.PowerShellAbstractComponent"
implements="com.intellij.plugin.powershell.psi.PowerShellComponent"}

private function_name ::= primary_expression | identifier //primary_expression | command_name
identifier ::= generic_identifier
private generic_identifier ::=  generic_token_with_sub_expr | generic_token_part


private function_parameter_declaration ::= LP parameter_list nls? RP
//private parameter_list ::= parameter_with_initializer (COMMA parameter_with_initializer)*
private parameter_list ::= script_parameter_list
//private script_parameter_list ::= script_parameter (nls? ',' script_parameter)*
//private parameter_with_initializer ::= simple_lvalue [ EQ expression ]
//private simple_lvalue ::= target_variable
//target_variable ::=  variable //DS ALNUM|DS LCURLY BRACED_ID RCURLY//Q_ANYCHAR


private labeled_statement ::=   switch_statement
                              | foreach_statement
                              | for_statement
                              | while_statement
                              | do_statement

switch_statement ::= 'switch' nls? switch_parameter* switch_condition switch_body
private switch_parameter ::=   '-regex'
                             | '-wildcard'
                             | '-exact'
                             | '-casesensitive'
                             | '-parallel'

private switch_condition ::= LP nls? pipeline nls? RP | '-file' nls? switch_filename
private switch_filename ::= command_argument | primary_expression
command_argument ::= path_expression | expression | command_name
path_expression ::= provider? drive? containers? item | relative_path
private provider ::= ( module? COLON2 nws )+
private module ::= module_name nws PATH_SEP nws
private drive ::= drive_name nws COLON nws PATH_SEP nws
private containers ::= (container nws PATH_SEP nws)+
private module_name ::= simple_name | primary_expression
private container ::= path_item_name
drive_name ::= simple_name | primary_expression
item ::= path_item_name
private path_item_name ::= generic_id_part_tokens_start (nws path_name_part_tokens)*
private path_name_part_tokens ::= generic_id_part_tokens_start | DOT
private relative_path ::= DOT (nws DOT)? | PATH_SEP
command_parameter ::= PARAM_TOKEN
verbatim_command_argument ::= VERBATIM_ARG_START VERBATIM_ARG_INPUT //(verbatim_command_string | AMP_ARG | generic_token_chars )+
//private verbatim_command_string ::= EXPANDABLE_STRING //TODO: 02/09/17 variable substitution:


private primary_expression ::= value (invocation_expression | member_access | element_access | post_increment_expression | post_decrement_expression)*

private left member_access ::= nws ( DOT | COLON2 ) member_name
private left element_access ::= SQBR_L nls? expression nls? SQBR_R
left invocation_expression ::= (DOT | COLON2 ) member_name LP argument_expression_list? nls? RP
private left argument_expression_list ::= expression ( ',' expression)*
left post_increment_expression ::= PP
left post_decrement_expression ::= MM

private member_name ::=   simple_name
                        | string_literal_expression
//->                        | string_literal_with_subexpression
                        | expression_with_unary_operator //prefix_op unary_expression //

                        | value

private value ::=   parenthesized_expression
                  | sub_expression
                  | array_expression
                  | script_block_expression
                  | hash_literal_expression
                  | literal
                  | type_literal_expression
//                  | prefix_op lvalue
                  | cast_expression
                  | target_variable_expression

parenthesized_expression ::= LP nls? pipeline nls? RP

private sub_expression ::= DS LP statement_list? RP

private array_expression ::= AT LP statement_list? RP

private script_block_expression ::= LCURLY nls? block_body? nls? RCURLY

private hash_literal_expression ::= AT LCURLY hash_literal_body? RCURLY //'@{' nls? hash_literal_body? nls? '}'
private hash_literal_body ::= hash_entry ( statement_terminators hash_entry )*
private hash_entry ::= key_expression '=' nls? statement

private key_expression ::= simple_name | unary_expression

// todo Note no whitespace is allowed after primary_expression.
//->private member_access ::= primary_expression ( DOT | '::' ) member_name

//todo  Note no whitespace is allowed between primary_expression and [.
//->private element_access ::= primary_expression '[' nls? expression nls? ']'

//->//todo  Note no whitespace is allowed after primary_expression.
//->private invocation_expression ::= primary_expression (DOT | '::') member_name argument_list
//->
//->private argument_list ::= LP argument_expression_list? nls? RP
//->private argument_expression_list ::= argument_expression ( ',' argument_expression)*
//->
//->private argument_expression ::=  nls? logical_argument_expression
//->
//->private logical_argument_expression ::= bitwise_argument_expression ( ('-and' | '-or' | '-xor') nls? bitwise_argument_expression )*
//->
//->private bitwise_argument_expression ::= comparison_argument_expression ( ('-band' | '-bor' | '-bxor') nls? comparison_argument_expression )*
//->
//->private comparison_argument_expression ::= additive_argument_expression ( comparison_operator nls? additive_argument_expression )*
//->
//->private additive_argument_expression ::= multiplicative_argument_expression ( (PLUS | MINUS) nls? multiplicative_argument_expression )*
//->
//->private multiplicative_argument_expression ::= format_argument_expression ( ('*' | '/' | '%') nls? format_argument_expression )*
//->
//->private format_argument_expression ::= range_argument_expression ( format_operator nls? range_argument_expression )*
//->
//->private range_argument_expression ::= unary_expression ( '..' nls? unary_expression )*
//->

private switch_body ::= nls? '{' nls? switch_clause+ '}'
private switch_clause ::= switch_clause_condition statement_block statement_terminators?
private switch_clause_condition ::= command_argument | primary_expression


foreach_statement ::= 'foreach' nls? '-parallel'? nls?
                                LP nls?   target_variable_expression   nls? 'in' nls? pipeline nls? RP nls? statement_block

//todo simplify
for_statement ::=   'for' nls? LP
                                  nls? for_initializer? sep
                                  nls? for_condition? sep
                                  nls? for_iterator?
                                  nls? RP statement_block

private for_initializer ::= pipeline
private for_condition ::= pipeline
private for_iterator ::= pipeline


while_statement ::= 'while' nls? LP nls? while_condition nls? RP nls? statement_block {pin(".*")=1}
private while_condition ::= nls? pipeline


do_statement ::= 'do' statement_block nls? ( 'while' | 'until' ) nls? LP while_condition nls? RP


if_statement ::= 'if' nls? LP nls? pipeline nls? RP nls? statement_block elseif_clause* else_clause?
private elseif_clause ::= nls? 'elseif' nls? LP nls? pipeline nls? RP nls? statement_block
private else_clause ::= nls? 'else' statement_block

sep ::= SEMI |  NLS | new_line_char | !is_id comment //COMMENT //hide psi
private nls ::= NLS
private new_line_char ::= LF

comment ::= requires_comment | SINGLE_LINE_COMMENT | DELIMITED_COMMENT
private requires_comment ::= HASH nws 'requires' ws command_argument+

private statement_terminators ::= sep+

private label ::= ':' LETTERS ALNUM?

private nws ::= <<isNotWhiteSpace>>

private ws ::= <<isWhiteSpace>>
private is_id ::= <<isIdentifierBefore>>
