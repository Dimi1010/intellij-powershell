{
  parserClass="com.intellij.plugin.powershell.lang.parser.PowerShellParser"
  parserImports=["static com.intellij.lang.parser.GeneratedParserUtilBase.*;"]

  psiImplUtilClass="com.intellij.plugin.powershell.psi.impl.PowerShellPsiImplUtil"

//  parserUtilClass="PwShellGeneratedParserUtil" //external grammar

    extends="com.intellij.plugin.powershell.psi.impl.PowerShellPsiElementImpl"
    implements="com.intellij.plugin.powershell.psi.PowerShellPsiElement"

    psiClassPrefix="PwShell"
    psiImplClassSuffix="ImplGen"
    psiPackage="com.intellij.plugin.powershell.psi"
    psiImplPackage="com.intellij.plugin.powershell.psi.impl"

    elementTypeHolderClass="com.intellij.plugin.powershell.psi.PowerShellTypes"
    elementTypeClass="com.intellij.plugin.powershell.lang.parser.PowerShellElementType"
    tokenTypeClass="com.intellij.plugin.powershell.lang.lexer.PowerShellTokenType"
    tokens = [

    // comparison operators
    OP_C = 'regexp:(-eq|-ne|-ge|-gt|-lt|-le|-ieq|-ine|-ige|-igt|-ilt|-ile|-ceq|-cne|-cge|-cgt|-clt|-cle|-like|-notlike|-match|-notmatch|-ilike|-inotlike|-imatch|-inotmatch|-clike|-cnotlike|-cmatch|-cnotmatch|-contains|-notcontains|-icontains|-inotcontains|-ccontains|-cnotcontains|-isnot|-is|-as|-replace|-ireplace|-creplace)'

  // NewLines and spaces //
    NLS ='regexp:(\r|\n|\r\n)( (\r|\n|\r\n)|([\ \t\f]) )*'
    LF = 'regexp:(\r|\n|\r\n)+'                                   // NewLines

    LP='('
    RP=')'


    STRING_LITERAL_DQ='regexp:"([^"\\]|\\.)*"'
    STRING_LITERAL_SQ="regexp:'[^']*'"
    DIGITS='regexp:[0-9]+'

    DEC_EXPONENT='regexp:[Ee][+-]?[0-9]+'
    var_identifier='regexp:([_a-zA-Z][a-zA-Z0-9_$\-]*)|(\|(([^\|])|(\\\|))*[^\\]\|)'

  //todo nested comments (lexer states...)
    COMMENT='regexp:((#.*)|(--.*)|((\(\*[^\*](([^\*]*(\*+[^\*\)])?)*(\*+\))?))|\(\*))'
    RAW_LBR='«'
    RAW_RBR='»'
    MULTI_LINE_COMMENT_START='(*'
    MULTI_LINE_COMMENT_END='*)'
    WHITE_SPACE='regexp:[\ \t\f]'

    COMMA=','
    LCURLY='{'
    RCURLY='}'
    COLON=':'
    DS='$'
    AT='@'
    EQ='='
    PIPE='|'


//    CMDLET_NAME ='regexp:([^$0-9(@"''][^ \t]*)' //todo
//    PARAM_ARGUMENT='regexp:([^-($0-9]\w*)' //todo
    PARAM_ARGUMENT='regexp:([\w][\w$0-9\-]*)' //todo
    ALNUM='regexp:p{Alnum}'
    LETTERS='regexp:[a-zA-Z]+'
    DS_ALNUM='regexp:\$\p{Alnum}+'
    DSQ_ANYCHAR='regexp:\$\{.*\}'
    PARAM_TOKEN='regexp:\-[a-zA-Z]+:?'//-[:letter:]+[:]{0 |1}
  ]
    extends(".*Expression")="expression"
    consumeTokenMethod(".*(Expression|Recover|Condition)")="consumeTokenFast"
}

scriptFile ::= ( statementBlock | statementList )*

statementBlock ::= LCURLY statementList RCURLY

private statementList ::= statement ( statementSeparatorToken statement? )*

/// statement
private statement ::=   ifStatement
                      | switchStatement
                      | foreachStatement
                      | forWhileStatement
                      | doWhileStatement
                      | functionDeclaration
                      | parameterDeclaration
                      | flowControlStatement
                      | trapStatement
                      | finallyStatement
                      | pipeline

// pipeline
pipeline ::= assignmentStatement | firstPipelineElement ( PIPE cmdletCall )*

assignmentStatement ::= lvalueExpression assignmentOperatorToken pipeline

//lvalueExpression ::=  lvalue ('?'|'?' lvalue)* // '?' ???
lvalueExpression ::=  lvalue ( PIPE lvalue)* // '?' ???

private lvalue ::= simpleLvalue propertyOrArrayReferenceOperator*

simpleLvalue ::= attributeSpecificationToken* targetVariable
//todo psi component identifier here?

private firstPipelineElement ::= expression | cmdletCall

cmdletCall ::= [ '&'|'.' ] ( cmdletNameToken | expression ) ( parameterToken | parameterArgumentToken | postfixOperator | redirection )*
private name ::= var_identifier
//private empty ::= var_identifier

redirection ::= redirectionOperatorToken propertyOrArrayReference

// if statement
ifStatement ::= 'if' LP pipeline RP
                            statementBlock ( 'elseif' LP pipeline RP statementBlock )*
                            [ 'else' statementBlock ] {pin=2}

// switch statement
switchStatement ::= 'switch' ['-regex'|'-wildcard'|'-exact' ]
                             ['-casesensitive']
                             ['-file' propertyOrArrayReference | LP pipeline RP ]
                             LCURLY ( [ 'default' | parameterArgumentToken | propertyOrArrayReference | statementBlock ] statementBlock )+ RCURLY

// foreach statement
foreachStatement ::=  loopLabelToken? 'foreach' LP targetVariable
                              'in' pipeline RP statementBlock

// for and while statements
forWhileStatement ::= loopLabelToken? 'while' LP pipeline RP
                               statementBlock|
                               loopLabelToken? 'for' LP pipeline? ';'
                               pipeline? ';' pipeline? RP
                               statementBlock {pin(".*")=3}

// do while/ do until statements
doWhileStatement ::= loopLabelToken? 'do' statementBlock ['while'|'until']
                              LP pipeline RP

// trap statement
trapStatement ::= 'trap' attributeSpecificationToken? statementBlock

// finally statement
finallyStatement ::= 'finally' statementBlock

// flow control statements
flowControlStatement ::= ('break'|'continue') [ propertyNameToken|propertyOrArrayReference ]
                               |'return' pipeline


// function declarations
functionDeclaration ::= functionDeclarationToken functionIdentifier //parameterArgumentToken ??
                                 [ LP parameterDeclarationExpression RP ]
                                 cmdletBody

// parameter declarations
parameterDeclaration ::= parameterDeclarationToken LP parameterDeclarationExpression RP
private parameterDeclarationToken ::= 'param'
private parameterDeclarationExpression ::=  parameterWithInitializer  ( commaToken parameterWithInitializer )*
private parameterWithInitializer ::= simpleLvalue [ EQ expression ]

// expressions
expression ::= logicalExpression

logicalExpression ::= bitwiseExpression (logicalOperatorToken bitwiseExpression)*

bitwiseExpression ::= comparisonExpression (bitwiseOperatorToken comparisonExpression)*

comparisonExpression ::= addExpression ( comparisonOperatorToken addExpression )*

addExpression ::=  multiplyExpression ( additionOperatorToken multiplyExpression )*

multiplyExpression ::= formatExpression [ multiplyOperatorToken formatExpression ]

formatExpression ::= rangeExpression ( formatOperatorToken rangeExpression )*

rangeExpression ::= arrayLiteral ( rangeOperatorToken arrayLiteral )*

arrayLiteral ::= postfixOperator ( commaToken postfixOperator )*

postfixOperator ::= lvalueExpression prePostfixOperatorToken | propertyOrArrayReference
propertyOrArrayReference ::= value propertyOrArrayReferenceOperator*

propertyOrArrayReferenceOperator ::= '[' expression ']' /*]*/|'.' /*[*/( propertyNameToken parseCall?|value )/*]*/// ]??

private parseCall ::= LP arrayLiteral RP

// value
value ::=
//                     (LP assignmentStatement RP )|
                     LP statementList RP|
                     DS LP statementList RP|
                     AT LP statementList RP|
                     cmdletBody|
                     DS LCURLY hashLiteral RCURLY|
                     unaryOperatorToken propertyOrArrayReference|
                     attributeSpecificationToken propertyOrArrayReference|
                     attributeSpecificationToken|
                     prePostfixOperatorToken lvalue|
                     numberToken|
                     literalStringToken|
                     referenceExpression //varIdentifier

hashLiteral ::= keyExpression EQ pipeline ( statementSeparatorToken hashLiteral )*

keyExpression ::= DS var_identifier //variableToken// ???

// tokenizer rules todo: extract to tokens
private comparisonOperatorToken ::= OP_C

private assignmentOperatorToken ::= EQ|'+='|'-='|'*='|'/='|'%='
private logicalOperatorToken ::= "-and"|"-or"
private bitwiseOperatorToken ::= "-band"|"-bor"
private redirectionOperatorToken ::= "2>&1"|">>"|">"|"<<"|"<"|">|"|"2>"|"2>>"|"1>>"
private functionDeclarationToken ::= 'function'|'filter'

literalStringToken ::= expandableStringToken|stringToken
//An expandable string does variable expansion inside them.
private expandableStringToken ::= STRING_LITERAL_DQ //".*"
private stringToken ::= STRING_LITERAL_SQ//'.*'

referenceExpression ::= variableNameToken
//todo psi reference identifier

targetVariable ::= variableNameToken
//todo psi component identifier

private variableNameToken ::=  DS_ALNUM|DSQ_ANYCHAR
private varName ::= var_identifier //todo


parameterToken ::=  PARAM_TOKEN //'-'LETTERS[':']

private callArgumentSeparatorToken ::= PIPE

//private commaToken ::= '|' //was <<-
private commaToken ::= COMMA

private minusMinusToken ::= '--'
private rangeOperatorToken ::= '..'

//private numberToken ::= ALNUM//C# number pattern...
numberToken ::= DIGITS //todo //('.'(DIGITS)(DEC_EXPONENT))|(dec_significand DEC_EXPONENT?)
//private dec_significand ::= ('.'DIGITS)|(DIGITS'.'DIGITS*)

private referenceOperatorToken ::= "."|"::"|"["


//The following token rule is used to parse command argument tokens. It is only active
//  after reading the command name itself. The goal is to allow any character in a command
//  argument other than statement delimiters (newline, semicolon, or close brace),
//  expression delimiters (close parenthesis, the pipe sysmbol), or whitespace. It’s a variation
//  of a string token (escaping works), but the token is delimited by any of a set of
//  characters. The regular expression shown does not accurately capture the full details of
//  how this works.
parameterArgumentToken ::= PARAM_ARGUMENT //[^-($0-9].*[^ \t] //was
//parameterArgumentToken ::= var_identifier
functionIdentifier ::= var_identifier

private unaryOperatorToken ::= "!"|"-not"|"+"|"-"|"-bnot"|attributeSpecificationToken
private formatOperatorToken ::= '-f'
//loopLabelToken  ::= [:LETTERS:][:alnum:]*:
private loopLabelToken ::= LETTERS ALNUM? ':'
private prePostfixOperatorToken ::= '++' | minusMinusToken
private multiplyOperatorToken ::= '*'|'/'|'%'
private additionOperatorToken ::= '+'|'-' /*|emDash|enDash|horizontalBar*/
//private emDash ::=
//private enDash ::=
//private horizontalBar ::=
//The attribute specification looks like [int] or [system.int32] and will also eventually
//  allow the full range of PowerShell metadata. // ::= \[..*\]
private attributeSpecificationToken ::= '[' var_identifier ('.' var_identifier)* ']'

private statementSeparatorToken ::= ';'|'&&'|'||'|LF //|NLS //<<eof>> //todo NLS (new line)

cmdletNameToken ::= var_identifier //CMDLET_NAME

cmdletBody ::= LCURLY [ LP parameterDeclarationExpression RP ]
                        (   ( 'begin' statementBlock
                           |'process' statementBlock
                           |'end' statementBlock )+
                       |statementList ) RCURLY

private propertyNameToken ::= varName //???
